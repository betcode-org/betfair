{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"betfairlightweight  <p>Lightweight, super fast (uses c libraries) pythonic wrapper for Betfair API-NG allowing all betting operations (including market and order streaming) and account operations.</p> <p>Get started...</p> <pre><code>&gt;&gt;&gt; import betfairlightweight\n&gt;&gt;&gt; trading = betfairlightweight.APIClient(\n        \"username\", \"password\", app_key=\"app_key\", certs=\"/certs\"\n    )\n&gt;&gt;&gt; trading.login()\n</code></pre> <p>Request all event types..</p> <pre><code>&gt;&gt;&gt; event_types = trading.betting.list_event_types()\n&gt;&gt;&gt; event_types\n[&lt;EventTypeResult&gt;, &lt;EventTypeResult&gt;, ..]\n</code></pre>"},{"location":"#endpoints","title":"Endpoints","text":"<ul> <li>trading.login</li> <li>trading.login_interactive</li> <li>trading.keep_alive</li> <li> <p>trading.logout</p> </li> <li> <p>trading.betting</p> </li> <li>trading.account</li> <li>trading.navigation</li> <li>trading.scores</li> <li>trading.streaming</li> <li> <p>trading.historical</p> </li> <li> <p>trading.in_play_service</p> </li> <li>trading.race_card</li> </ul> <p>Warning</p> <p>in_play_service and race_card are not public endpoints so may break, they are used by the betfair.com website.</p>"},{"location":"#dependencies","title":"Dependencies","text":"<p>betfairlightweight relies on these libraries:</p> <ul> <li><code>requests</code> - HTTP support</li> </ul> <p>Speed install:</p> <ul> <li><code>ciso8601</code> - C based datetime parsing</li> <li><code>orjson</code> - Rust based json parsing</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Install with pip:</p> <pre><code>$ pip install betfairlightweight\n</code></pre> <p>or to use C/Rust libraries install with</p> <pre><code>$ pip install betfairlightweight[speed]\n</code></pre> <p>betfairlightweight requires Python 3.9+</p>"},{"location":"advanced/","title":"Advanced","text":""},{"location":"advanced/#locale","title":"Locale","text":"<p>Betfair uses slightly different endpoints depending on your country of residence, these can be used by changing the locale on client initialisation:</p> <pre><code>&gt;&gt;&gt; trading = betfairlightweight.APIClient(\n        \"username\", \n        \"password\", \n        app_key=\"app_key\", \n        locale=\"italy\"\n    )\n</code></pre> <ul> <li>spain</li> <li>italy</li> <li>romania</li> <li>sweden</li> <li>australia</li> </ul>"},{"location":"advanced/#nemid-login","title":"NEMID Login","text":"<p>Danish residents are restricted in how they login due to NemID requirements, this can be handled by replicating the login flow:</p> <pre><code>import re\nimport betfairlightweight\n\ntrading = betfairlightweight.APIClient(\"username\", \"password\", app_key=\"app_key\")\n\nresp = trading.session.post(\n    url=trading.login_interactive.url,\n    data={\n        \"username\": trading.username,\n        \"password\": trading.password,\n        \"redirectMethod\": \"POST\",\n        \"product\": trading.app_key,\n        \"url\": \"https://www.betfair.com\",\n        \"submitForm\": True,\n    }\n)\nsession_token = re.findall(\n    \"ssoid=(.*?);\", resp.headers[\"Set-Cookie\"]\n)\ntrading.set_session_token(session_token[0])\n\nprint(trading.betting.list_event_types())\n</code></pre>"},{"location":"advanced/#session","title":"Session","text":"<p>The client assumes requests is used for the http requests but other clients can be used if required, a session object can be passed to the client:</p> <pre><code>&gt;&gt;&gt; session = requests.session()\n&gt;&gt;&gt; trading = betfairlightweight.APIClient(\n        \"username\", \n        \"password\", \n        app_key=\"app_key\", \n        session=session,\n    )\n</code></pre> <p>or on a per requests basis:</p> <pre><code>&gt;&gt;&gt; trading.betting.list_event_types(\n        filter=filters.market_filter(\n            text_query='Horse Racing'\n        ),\n        session=session,\n    )\n</code></pre>"},{"location":"advanced/#response","title":"Response","text":"<p>The response object contains the following extra attributes:</p> <pre><code>&gt;&gt;&gt; response = trading.betting.list_event_types(\n        filter=filters.market_filter(\n            text_query='Horse Racing'\n        ),\n        session=session,\n    )\n</code></pre> <p>Raw data / json response:</p> <pre><code>&gt;&gt;&gt; response[0]._data\n{'eventType': {'id': '7', 'name': 'Horse Racing'}, 'marketCount': 328}\n\n&gt;&gt;&gt; response[0].json()\n{\"eventType\":{\"id\":\"7\",\"name\":\"Horse Racing\"},\"marketCount\":328}\n</code></pre> <p>Elapsed, created and updated time:</p> <pre><code>&gt;&gt;&gt; response[0].elapsed_time\n0.14815688133239746\n\n&gt;&gt;&gt; response[0]._datetime_created\n2020-01-27 09:56:32.984387\n\n&gt;&gt;&gt; response[0]._datetime_updated\n2020-01-27 09:56:32.984387\n</code></pre> <p>Raw requests response object:</p> <pre><code>&gt;&gt;&gt; response[0]._response\n&lt;Response [200]&gt;\n</code></pre>"},{"location":"advanced/#lightweight","title":"Lightweight","text":"<p>In order to return the raw json you can select lightweight on client initialization:</p> <pre><code>&gt;&gt;&gt; trading = betfairlightweight.APIClient(\n        \"username\", \n        \"password\", \n        app_key=\"app_key\", \n        certs=\"/certs\", \n        lightweight=True,\n    )\n&gt;&gt;&gt; trading.login()\n{'sessionToken': 'dfgrtegreg===rgrgr', 'loginStatus': 'SUCCESS'}\n</code></pre> <p>or on a per request basis:</p> <pre><code>&gt;&gt;&gt; trading.betting.list_event_types(\n        filter=filters.market_filter(\n            text_query='Horse Racing'\n        ),\n        lightweight=True,\n    )\n[{'eventType': {'id': '7', 'name': 'Horse Racing'}, 'marketCount': 328}]\n</code></pre> <p>Hint</p> <p>Because lightweight means python doesn't need to create objects it can be considerably faster but harder to work with.</p>"},{"location":"advanced/#dependencies","title":"Dependencies","text":"<p>By default betfairlightweight will install C and Rust based libraries if your os is either linux or darwin (Mac), due to difficulties in installation Windows users can install them separately:</p> <pre><code>$ pip install betfairlightweight[speed]\n</code></pre> <p>Hint</p> <p>If using windows it is likely that visual studio will need to be installed as well. </p>"},{"location":"advanced/#performance","title":"Performance","text":"<p>As detailed above using lightweight mode and the [speed] install improves the performance of bflw however it is possible to further improve the speed of backtesting by setting the following on the <code>Listener</code>:</p> <pre><code>listener = betfairlightweight.StreamListener(\n    max_latency=None,  # ignore latency errors\n    output_queue=None,  # use generator rather than a queue (faster)\n    lightweight=True,  # lightweight mode is faster\n    update_clk=False,  # do not update clk on updates (not required when backtesting)\n)\n</code></pre> <p>For any further inspiration on speeding up backtesting have a read of the flumine source code, especially patching.py and historicalstream.py</p>"},{"location":"endpoints/","title":"Endpoints","text":""},{"location":"endpoints/#login","title":"Login","text":"<pre><code>trading.login()\n</code></pre>"},{"location":"endpoints/#login-interactive","title":"Login Interactive","text":"<pre><code>trading.login_interactive()\n</code></pre>"},{"location":"endpoints/#keep-alive","title":"Keep Alive","text":"<pre><code>trading.keep_alive()\n</code></pre>"},{"location":"endpoints/#logout","title":"Logout","text":"<pre><code>trading.logout()\n</code></pre>"},{"location":"endpoints/#betting","title":"Betting","text":"<pre><code>trading.betting.list_event_types()\n</code></pre> <pre><code>trading.betting.list_competitions()\n</code></pre> <pre><code>trading.betting.list_time_ranges()\n</code></pre> <pre><code>trading.betting.list_events()\n</code></pre> <pre><code>trading.betting.list_market_types()\n</code></pre> <pre><code>trading.betting.list_countries()\n</code></pre> <pre><code>trading.betting.list_venues()\n</code></pre> <pre><code>trading.betting.list_market_catalogue()\n</code></pre> <pre><code>trading.betting.list_market_book()\n</code></pre> <pre><code>trading.betting.list_runner_book()\n</code></pre> <pre><code>trading.betting.list_current_orders()\n</code></pre> <pre><code>trading.betting.list_cleared_orders()\n</code></pre> <pre><code>trading.betting.list_market_profit_and_loss()\n</code></pre> <pre><code>trading.betting.place_orders()\n</code></pre> <pre><code>trading.betting.cancel_orders()\n</code></pre> <pre><code>trading.betting.update_orders()\n</code></pre> <pre><code>trading.betting.replace_orders()\n</code></pre>"},{"location":"endpoints/#account","title":"Account","text":"<pre><code>trading.account.get_account_funds()\n</code></pre> <pre><code>trading.account.get_account_details()\n</code></pre> <pre><code>trading.account.get_account_statement()\n</code></pre> <pre><code>trading.account.list_currency_rates()\n</code></pre> <pre><code>trading.account.transfer_funds()\n</code></pre>"},{"location":"endpoints/#navigation","title":"Navigation","text":"<pre><code>trading.navigation.list_navigation()\n</code></pre>"},{"location":"endpoints/#scores","title":"Scores","text":"<pre><code>trading.scores.list_race_details()\n</code></pre> <pre><code>trading.scores.list_available_events()\n</code></pre> <pre><code>trading.scores.list_scores()\n</code></pre> <pre><code>trading.scores.list_incidents()\n</code></pre>"},{"location":"endpoints/#streaming","title":"Streaming","text":"<pre><code>trading.streaming.create_stream()\n</code></pre> <pre><code>trading.streaming.create_historical_stream()\n</code></pre> <pre><code>trading.streaming.create_historical_generator_stream()\n</code></pre>"},{"location":"endpoints/#historical","title":"Historical","text":"<pre><code>trading.historic.get_my_data()\n</code></pre> <pre><code>trading.historic.get_collection_options()\n</code></pre> <pre><code>trading.historic.get_data_size()\n</code></pre> <pre><code>trading.historic.get_file_list()\n</code></pre> <pre><code>trading.historic.download_file()\n</code></pre>"},{"location":"endpoints/#in-play-service","title":"In Play Service","text":"<pre><code>trading.in_play_service.get_event_timeline()\n</code></pre> <pre><code>trading.in_play_service.get_event_timelines()\n</code></pre> <pre><code>trading.in_play_service.get_scores()\n</code></pre>"},{"location":"endpoints/#race-card","title":"Race Card","text":"<pre><code>trading.race_card.login()\n</code></pre> <pre><code>trading.race_card.get_race_card()\n</code></pre> <pre><code>trading.race_card.get_race_result()\n</code></pre>"},{"location":"help/","title":"Help","text":"<p>Please try the following channels for any support:</p> <ul> <li>Betfair Developer Support</li> <li>Slack Group for any help in using the library</li> <li>API Status if things don't seem to be working</li> </ul>"},{"location":"quickstart/","title":"QuickStart","text":"<p>First, start by importing betfairlightweight:</p> <pre><code>&gt;&gt;&gt; import betfairlightweight\n</code></pre> <p>Now, try logging in:</p> <pre><code>&gt;&gt;&gt; trading = betfairlightweight.APIClient(\n        \"username\", \"password\", app_key=\"app_key\", certs=\"/certs\"\n    )\n&gt;&gt;&gt; trading.login()\n&lt;LoginResource&gt;\n</code></pre> <p>If you do not have certificates setup on your account you can use the interactive login:</p> <pre><code>&gt;&gt;&gt; trading = betfairlightweight.APIClient(\n        \"username\", \"password\", app_key=\"app_key\"\n    )\n&gt;&gt;&gt; trading.login_interactive()\n&lt;LoginResource&gt;\n</code></pre> <p>Danger</p> <p>It is strongly recommended to use certificates combined with 2FA when logging in.</p> <p>Once logged in the client stores the login time and session token:</p> <pre><code>&gt;&gt;&gt; trading.session_token\n'ergregergreger==regregreg'\n\n&gt;&gt;&gt; trading.session_expired\nFalse\n</code></pre> <p>Once logged in you can keep the session alive or logout:</p> <pre><code>&gt;&gt;&gt; trading.keep_alive()\n&lt;KeepAliveResource&gt;\n\n&gt;&gt;&gt; trading.logout()\n&lt;LogoutResource&gt;\n</code></pre>"},{"location":"quickstart/#data","title":"Data","text":"<p>The client matches the API-NG by splitting the operations per endpoint, therefore in order to list all event types:</p> <pre><code>&gt;&gt;&gt; results = trading.betting.list_event_types()\n[&lt;EventTypeResult&gt;, &lt;EventTypeResult&gt;, ...\n</code></pre> <p>The responses are parsed into python objects allowing easy use:</p> <pre><code>&gt;&gt;&gt; for i in results:\n        print(i.event_type.id, i.event_type.name, i.market_count)\n\n1 Soccer 2381\n2 Tennis 3402\n3 Golf 9\n4 Cricket 380\n5 Rugby Union 29\n...\n</code></pre> <p>Or to list events using a market filter:</p> <pre><code>&gt;&gt;&gt; from betfairlightweight import filters\n\n&gt;&gt;&gt; racing_filter = filters.market_filter(text_query=\"Horse Racing\")\n&gt;&gt;&gt; results = trading.betting.list_events(\n        filter=racing_filter\n    )\n[&lt;EventResult&gt;, &lt;EventResult&gt;, ...\n</code></pre> <pre><code>&gt;&gt;&gt; for i in results:\n        print(i.event.id, i.event.name, i.market_count)\n\n29324768 Aintree 4th Apr 1\n29660708 Arar (AUS) 21st Jan 14\n29661349 Aque (US) 20th Jan 9\n29636646 Newmarket 3rd May 1\n29660974 Wolv 20th Jan 32\n...\n</code></pre> <p>Get static market data using listMarketCatalogue:</p> <pre><code>&gt;&gt;&gt; racing_filter = filters.market_filter(\n        event_type_ids=[7],  # filter on just horse racing\n        market_countries=[\"GB\"],  # filter on just GB countries\n        market_type_codes=[\"WIN\"],  # filter on just WIN market types\n    )\n&gt;&gt;&gt; results = trading.betting.list_market_catalogue(\n        market_projection=[\n            \"RUNNER_DESCRIPTION\", \n            \"RUNNER_METADATA\", \n            \"COMPETITION\", \n            \"EVENT\", \n            \"EVENT_TYPE\", \n            \"MARKET_DESCRIPTION\", \n            \"MARKET_START_TIME\",\n        ],\n        filter=racing_filter,\n        max_results=100,\n    )\n[&lt;MarketCatalogue&gt;, &lt;MarketCatalogue&gt;, ...\n</code></pre> <pre><code>&gt;&gt;&gt; for i in results:\n        print(\n            \"{0} {1:d}:{2:02d} {3} ({4})\".format(\n                i.market_id,\n                i.market_start_time.hour, \n                i.market_start_time.minute, \n                i.event.venue,  \n                i.description.market_type,\n            )\n        )\n\n1.167697086 18:00 Kempton (PLACE)\n1.167697085 18:00 Kempton (WIN)\n1.167697089 18:00 Kempton (OTHER_PLACE)\n1.167724518 18:20 Sam Houston Race Park (WIN)\n1.167724731 18:29 Tampa Bay Downs (OTHER_PLACE)\n1.167724730 18:29 Tampa Bay Downs (WIN)\n1.167758596 18:30 Kempton (REV_FORECAST)\n1.167756729 18:30 Kempton (MATCH_BET)\n...\n</code></pre> <p>Dynamic market price request using listMarketBook</p> <pre><code>&gt;&gt;&gt; market_books = trading.betting.list_market_book(\n        market_ids=[\"1.167697085\"],\n        price_projection=filters.price_projection(\n            price_data=filters.price_data(ex_all_offers=True)\n        ),\n    )\n</code></pre> <p>Loop response and print marketBook data:</p> <pre><code>&gt;&gt;&gt; for market_book in market_books:\n        print(  # prints market id, inplay?, status and total matched\n            market_book.market_id,\n            market_book.inplay,\n            market_book.status,\n            market_book.total_matched,\n        )\n        for runner in market_book.runners:  \n            print (  # prints selection id, status, LPT and total matched\n                runner.selection_id, \n                runner.status, \n                runner.last_price_traded, \n                runner.total_matched,\n            )\n\n1.167697085 False OPEN 230638.0\n27024606 ACTIVE 2.38 147131.93\n27596981 ACTIVE 3.25 52257.48\n26105369 ACTIVE 9.4 15378.91\n27596982 ACTIVE 21.0 8247.93\n27596980 ACTIVE 24.0 2763.9\n27596984 ACTIVE 40.0 1175.25\n27596985 ACTIVE 38.0 1260.61\n27596983 ACTIVE 70.0 1074.73\n27062522 ACTIVE 85.0 1096.03\n27596986 ACTIVE 320.0 251.17\n</code></pre>"},{"location":"quickstart/#place-order","title":"Place Order","text":"<p>Hint</p> <p>Order requests have limits, please review Betfair documentation for more information.</p> <pre><code>&gt;&gt;&gt; market_id = \"1.131347484\"\n&gt;&gt;&gt; selection_id = 12029579\n&gt;&gt;&gt; limit_order = filters.limit_order(\n        size=2.00, price=1.01, persistence_type=\"LAPSE\"\n    )\n&gt;&gt;&gt; instruction = filters.place_instruction(\n        order_type=\"LIMIT\",\n        selection_id=selection_id,\n        side=\"LAY\",\n        limit_order=limit_order,\n    )\n&gt;&gt;&gt; place_orders = trading.betting.place_orders(\n        market_id=market_id, instructions=[instruction]  # list\n    )\n\n&gt;&gt;&gt; print(place_orders.status)\n&gt;&gt;&gt; for order in place_orders.place_instruction_reports:\n        print(\n            \"Status: {0}, BetId: {1}, Average Price Matched: {2}\".format(\n                order.status, \n                order.bet_id, \n                order.average_price_matched\n            )\n        )\n\nSUCCESS\nStatus: SUCCESS, BetId: 192329047378, Average Price Matched: 0.0\n</code></pre>"},{"location":"quickstart/#update-order","title":"Update Order","text":"<pre><code>&gt;&gt;&gt; bet_id = 192329047378\n&gt;&gt;&gt; instruction = filters.update_instruction(\n        bet_id=bet_id, new_persistence_type=\"PERSIST\"\n    )\n&gt;&gt;&gt; update_order = trading.betting.update_orders(\n        market_id=market_id, instructions=[instruction]\n    )\n\n&gt;&gt;&gt; print(update_order.status)\n&gt;&gt;&gt; for order in update_order.update_instruction_reports:\n        print(\"Status: {0}\".format(order.status))\n\nSUCCESS\nStatus: SUCCESS\n</code></pre>"},{"location":"quickstart/#replace-order","title":"Replace Order","text":"<pre><code>&gt;&gt;&gt; instruction = filters.replace_instruction(bet_id=bet_id, new_price=1.10)\n&gt;&gt;&gt; replace_order = trading.betting.replace_orders(\n        market_id=market_id, instructions=[instruction]\n    )\n\n&gt;&gt;&gt; print(replace_order.status)\n&gt;&gt;&gt; for order in replace_order.replace_instruction_reports:\n        place_report = order.place_instruction_reports\n        cancel_report = order.cancel_instruction_reports\n        print(\n            \"Status: {0}, New BetId: {1}, Average Price Matched: {2}\".format(\n                order.status, \n                place_report.bet_id, \n                place_report.average_price_matched,\n            )\n        )\n\nSUCCESS\nStatus: SUCCESS, New BetId: 192329894811, Average Price Matched: 0.0 \n</code></pre>"},{"location":"quickstart/#cancel-order","title":"Cancel Order","text":"<p>Hint</p> <p>Placing a cancel request with no betId will result in all orders for that market being cancelled and placing a cancel request without a marketId will result in all open orders across all markets being cancelled.</p> <pre><code>&gt;&gt;&gt; instruction = filters.cancel_instruction(bet_id=bet_id, size_reduction=2.00)\n&gt;&gt;&gt; cancel_order = trading.betting.cancel_orders(\n        market_id=market_id, instructions=[instruction]\n    )\n\n&gt;&gt;&gt; print(cancel_order.status)\n&gt;&gt;&gt; for cancel in cancel_order.cancel_instruction_reports:\n        print(\n            \"Status: {0}, Size Cancelled: {1}, Cancelled Date: {2}\".format(\n                cancel.status, \n                cancel.size_cancelled, \n                cancel.cancelled_date,\n            )\n        )\n\nSUCCESS\nStatus: SUCCESS, Size Cancelled: 2.0, Cancelled Date: 2020-01-22 18:08:57\n</code></pre>"},{"location":"streaming/","title":"Streaming","text":""},{"location":"streaming/#why-streaming","title":"Why streaming?","text":"<p>If your aim is to take a snapshot of horse markets 3 minutes before the off and at post time, polling (listMarketBook) is a good solution. You will only hit the Betfair API endpoint 2 times per market. But if you want to gather, process and react to data more frequently (e.g. in-play horse racing), polling is inefficient and the reason lies in the way HTTP works. Every time you hit a Betfair API endpoint:</p> <ul> <li>Your machine establishes a new connection with the Betfair server.</li> <li>It sends an HTTP request and receives and HTTP response.</li> <li>HTTP requests/responses carry headers, so more data is sent/received.</li> </ul> <p>Streaming is more efficient because:</p> <ul> <li>The connection gets established once.</li> <li>From that moment, data keeps flowing from Betfair to your machine.</li> <li>There are no data overheads as you would have with polling / HTTP.</li> <li>This results in faster data and less CPU from your machine (and Betfair's)</li> </ul> <p>The full docs can be found here</p>"},{"location":"streaming/#market","title":"Market","text":"<p>A market stream can be created like so:</p> <pre><code>import queue\nimport threading\n\nimport betfairlightweight\nfrom betfairlightweight.filters import (\n    streaming_market_filter,\n    streaming_market_data_filter,\n)\n\ntrading = betfairlightweight.APIClient(\"username\", \"password\", app_key=\"appKey\")\ntrading.login()\n\n# create queue\noutput_queue = queue.Queue()\n\n# create stream listener\nlistener = betfairlightweight.StreamListener(output_queue=output_queue)\n\n# create stream\nstream = trading.streaming.create_stream(listener=listener)\n\n# create filters (GB WIN racing)\nmarket_filter = streaming_market_filter(\n    event_type_ids=[\"7\"], country_codes=[\"GB\"], market_types=[\"WIN\"]\n)\nmarket_data_filter = streaming_market_data_filter(\n    fields=[\"EX_BEST_OFFERS\", \"EX_MARKET_DEF\"], ladder_levels=3\n)\n\n# subscribe\nstreaming_unique_id = stream.subscribe_to_markets(\n    market_filter=market_filter,\n    market_data_filter=market_data_filter,\n    conflate_ms=1000,  # send update every 1000ms\n)\n\n# start stream in a new thread (in production would need err handling)\nt = threading.Thread(target=stream.start, daemon=True)\nt.start()\n\n# check for updates in output queue\nwhile True:\n    market_books = output_queue.get()\n    print(market_books)\n\n    for market_book in market_books:\n        print(\n            market_book,\n            market_book.streaming_unique_id,  # unique id of stream (returned from subscribe request)\n            market_book.streaming_update,  # json update received\n            market_book.market_definition,  # streaming definition, similar to catalogue request\n            market_book.publish_time,  # betfair publish time of update\n        )\n</code></pre>"},{"location":"streaming/#order","title":"Order","text":"<p>Warning</p> <p>The order stream does not include matched positions, these can be found by making a getCurrentOrders request. However 'price point' matched backs and matched lays are stored in the order cache in matched_lays / matched_backs.</p> <p>Order stream is similar to market:</p> <pre><code>import queue\nimport threading\n\nimport betfairlightweight\nfrom betfairlightweight.filters import streaming_order_filter\n\ntrading = betfairlightweight.APIClient(\"username\", \"password\", app_key=\"appKey\")\ntrading.login()\n\n# create queue\noutput_queue = queue.Queue()\n\n# create stream listener\nlistener = betfairlightweight.StreamListener(output_queue=output_queue)\n\n# create stream\nstream = trading.streaming.create_stream(listener=listener)\n\n# create filters (GB WIN racing)\norder_filter = streaming_order_filter()\n\n# subscribe\nstreaming_unique_id = stream.subscribe_to_orders(\n    order_filter=order_filter,\n    conflate_ms=1000,  # send update every 1000ms\n)\n\n# start stream in a new thread (in production would need err handling)\nt = threading.Thread(target=stream.start, daemon=True)\nt.start()\n\n# check for updates in output queue\nwhile True:\n    current_orders = output_queue.get()\n    print(current_orders)\n</code></pre>"},{"location":"streaming/#order-matches","title":"Order - Matches","text":"<p>In addition to <code>orders</code> and the <code>moreAvailable</code> flag the streaming output has a <code>matches</code> field which contains a list of the selections with <code>matchedBacks</code> and <code>matchedLays</code>.</p> <pre><code>&gt;&gt;&gt; current_orders.matches\n[&lt;bettingresources.Match&gt;, &lt;bettingresources.Match&gt;]\n</code></pre>"},{"location":"streaming/#historical","title":"Historical","text":"<p>Betfairlightweight can also handle historical streaming data that has been purchased from Betfair or collected yourself. </p> <pre><code>&gt;&gt;&gt; trading = betfairlightweight.APIClient(\"username\", \"password\")\n\n    # create listener\n&gt;&gt;&gt; listener = StreamListener(max_latency=None)\n\n    # create historical stream, update file_path to file location\n&gt;&gt;&gt; stream = trading.streaming.create_historical_stream(\n        file_path=\"/tmp/BASIC-1.132153978\",\n        listener=listener,\n    )\n\n    # start stream\n&gt;&gt;&gt; stream.start()\n</code></pre> <p>Tip</p> <p>The streaming code is highly optimised however to further improve speed the <code>update_clk</code> flag can be set to False on the listener <code>StreamListener(update_clk=False)</code> however update_clk is required to be True when live streaming (resubscribe uses it).</p> <p>The historical stream can be used in the same way as the market/order stream allowing backtesting / market processing.</p> <p>It is also possible to return a generator instead which can be easier to use (no threads) and uses less ram:</p> <pre><code>    # create historical generator stream, update directory to file location\n&gt;&gt;&gt; stream = trading.streaming.create_historical_generator_stream(\n        file_path=\"/tmp/BASIC-1.132153978\",\n        listener=listener,\n    )\n\n    # create genertaor\n&gt;&gt;&gt; g = stream.get_generator()\n\n&gt;&gt;&gt; for market_books in g():\n        print(market_books)\n\n[&lt;MarketBook&gt;]\n..\n</code></pre> <p>Tip</p> <p>When using betfair purchased historical data the listener vars <code>calculate_market_tv</code> and <code>cumulative_runner_tv</code> are required to access <code>totalMatched</code> in the market and runner books (depending on data package)</p>"},{"location":"streaming/#snap","title":"Snap","text":"<p>Instead of waiting for an update you can snap the listener to get an up to date version of the data.</p> <pre><code>&gt;&gt;&gt; market_books = listener.snap(\n        market_ids=[\"1.12345323\"]\n    )\n</code></pre> <p>Tip</p> <p>The streaming unique id is returned in the marketBook / orderBook which allows multiple streams to be differentiated if multiple streams feed into the same queue.</p> <p><code>market_book.streaming_unique_id</code></p>"},{"location":"streaming/#resubscribe","title":"Resubscribe","text":"<p>If you have lost connection and need to resubscribe (prevents a full image being sent) you can provide the following:</p> <pre><code>&gt;&gt;&gt; streaming_unique_id = stream.subscribe_to_markets(\n        market_filter=market_filter,\n        market_data_filter=market_data_filter,\n        conflate_ms=1000,  # send update every 1000ms\n        initial_clk=listener.initial_clk,\n        clk=listener.clk,\n    )\n</code></pre>"},{"location":"streaming/#error-handling","title":"Error Handling","text":"<p>When used in production it is recommended not to start the stream in a new thread and forgot about it, it will break, errors need to be caught. </p> <p>Please see the example examplestreamingerrhandling.py</p> <p>Sometimes betfair will suspend the stream via the use of a status=503 update, more info here, when the stream is receiving this update the <code>listener.status</code> will be updated:</p> <pre><code>&gt;&gt;&gt; listener.status\n503\n</code></pre>"},{"location":"streaming/#listener","title":"Listener","text":"<p>You can create a custom listener by overriding the listener class:</p> <pre><code>import betfairlightweight\n\n\nclass MyListener(betfairlightweight.StreamListener):\n    def on_data(self, raw_data: str) -&gt; Optional[bool]:\n        print(raw_data)\n\n\ncustom_listener = MyListener()\n</code></pre>"},{"location":"streaming/#logging","title":"Logging","text":"<p>In order to debug the stream update the logging level to DEBUG:</p> <pre><code>import logging\n\nlogging.basicConfig(level=logging.DEBUG)\n</code></pre> <p>Tip</p> <p>By default <code>max_latency</code> is set to 0.5, this means a warning will be logged if the latency between the publishTime and your machines time is greater than this number. Often you will need to check that your clock is up to date, however this can be removed by setting <code>max_latency=None</code> when initializing the listener.</p>"}]}